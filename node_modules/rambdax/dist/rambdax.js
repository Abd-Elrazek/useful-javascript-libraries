'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function type(a) {
  const typeOf = typeof a;

  if (a === null) {
    return 'Null';
  } else if (a === undefined) {
    return 'Undefined';
  } else if (typeOf === 'boolean') {
    return 'Boolean';
  } else if (typeOf === 'number') {
    return 'Number';
  } else if (typeOf === 'string') {
    return 'String';
  } else if (Array.isArray(a)) {
    return 'Array';
  } else if (a instanceof RegExp) {
    return 'RegExp';
  }

  const asStr = a.toString();

  if (asStr.startsWith('async')) {
    return 'Async';
  } else if (asStr === '[object Promise]') {
    return 'Promise';
  } else if (asStr.includes('function') || asStr.includes('=>')) {
    return 'Function';
  }

  return 'Object';
}

function allFalse(...inputs) {
  let counter = 0;

  while (counter < inputs.length) {
    const x = inputs[counter];

    if (type(x) === 'Function') {
      if (inputs[counter]()) {

        return false;
      }
    } else if (inputs[counter]) {

      return false;
    }

    counter++;
  }

  return true;
}

function allTrue(...inputs) {
  let counter = 0;
  while (counter < inputs.length) {
    const x = inputs[counter];

    if (type(x) === 'Function') {
      if (!inputs[counter]()) {
        return false;
      }
    } else if (!inputs[counter]) {
      return false;
    }

    counter++;
  }

  return true;
}

function anyFalse(...inputs) {

  let counter = 0;
  while (counter < inputs.length) {
    if (!inputs[counter]) {
      return true;
    }
    counter++;
  }

  return false;
}

function anyTrue(...inputs) {

  let counter = 0;
  while (counter < inputs.length) {
    if (inputs[counter]) {
      return true;
    }
    counter++;
  }

  return false;
}

/**Used as the `TypeError` message for "Functions" methods. */
const FUNC_ERROR_TEXT = 'Expected a function';

/**Used to stand-in for `undefined` hash values. */
const HASH_UNDEFINED = '__lodash_hash_undefined__';

/**Used as references for various `Number` constants. */
let INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/**`Object#toString` result references. */
let funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/**Used to match property names within property paths. */
let reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
const reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/**Used to match backslashes in property paths. */
const reEscapeChar = /\\(\\)?/g;

/**Used to detect host constructors (Safari). */
const reIsHostCtor = /^\[object .+?Constructor\]$/;

/**Used to detect unsigned integer values. */
const reIsUint = /^(?:0|[1-9]\d*)$/;

/**Detect free variable `global` from Node.js. */
const freeGlobal = typeof global === 'object' && global && global.Object === Object && global;

/**Detect free variable `self`. */
const freeSelf = typeof self === 'object' && self && self.Object === Object && self;

/**Used as a reference to the global object. */
const root = freeGlobal || freeSelf || /*#__PURE__*/Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  //Many host objects are `Object` objects that can coerce to strings
  //despite having improperly defined `toString` methods.
  let result = false;
  if (value != null && typeof value.toString !== 'function') {
    try {
      result = Boolean(String(value));
    } catch (e) {}
  }

  return result;
}

/**Used for built-in method references. */
let arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/**Used to detect overreaching core-js shims. */
const coreJsData = root['__core-js_shared__'];

/**Used to detect methods masquerading as native. */
const maskSrcKey = /*#__PURE__*/function () {
  const uid = /*#__PURE__*//[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');

  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**Used to resolve the decompiled source of functions. */
const funcToString = funcProto.toString;

/**Used to check objects for own properties. */
const hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
const objectToString = objectProto.toString;

/**Used to detect if a method is native. */
const reIsNative = /*#__PURE__*/RegExp('^' + /*#__PURE__*/funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**Built-in value references. */
let Symbol$1 = root.Symbol,
    splice = arrayProto.splice;

/*Built-in method references that are verified to be native. */
let Map = /*#__PURE__*/getNative(root, 'Map'),
    nativeCreate = /*#__PURE__*/getNative(Object, 'create');

/**Used to convert symbols to primitives and strings. */
let symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  let index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    const entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  const data = this.__data__;
  if (nativeCreate) {
    const result = data[key];

    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  const data = this.__data__;

  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  const data = this.__data__;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;

  return this;
}

//Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  let index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    const entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  let data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  const lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  let data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  let data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

//Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  let index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    const entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    hash: new Hash(),
    map: new (Map || ListCache)(),
    string: new Hash()
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key).delete(key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);

  return this;
}

//Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  const objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  let length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  const pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;

  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = isKey(path, object) ? [path] : castPath(path);

  let index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    let key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      const objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  //Exit early for strings to avoid a performance hit in some environments.
  if (typeof value === 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  const result = String(value);

  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  const data = map.__data__;

  return isKeyable(key) ? data[typeof key === 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  const value = getValue(object, key);

  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;

  return Boolean(length) && (typeof value === 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  const type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  const type = typeof value;

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return Boolean(maskSrcKey) && maskSrcKey in func;
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = /*#__PURE__*/memoize(string => {
  string = toString(string);

  const result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, (match, number, quote, string) => {
    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
  });

  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value === 'string' || isSymbol(value)) {
    return value;
  }
  const result = String(value);

  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return String(func);
    } catch (e) {}
  }

  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func !== 'function' || resolver && typeof resolver !== 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function () {
    let args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = func.apply(this, args);
    memoized.cache = cache.set(key, result);

    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();

  return memoized;
}

//Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  //The use of `Object#toString` avoids issues with the `typeof` operator
  //in Safari 8-9 which returns 'object' for typed array and other constructors.
  const tag = isObject(value) ? objectToString.call(value) : '';

  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  const type = typeof value;

  return Boolean(value) && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return Boolean(value) && typeof value === 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value === 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

//Its lodash's set method taken from

const isObject$1 = x => {
  const ok = x !== null && !Array.isArray(x) && typeof x === 'object';
  if (!ok) {
    return false;
  }

  return Object.keys(x).length > 0;
};

function change(origin, pathRaw, rules) {
  const willReturn = JSON.parse(JSON.stringify(origin));

  if (!isObject$1(rules)) {
    set(willReturn, pathRaw, rules);

    return willReturn;
  }
  const path = pathRaw === '' ? '' : `${pathRaw}.`;

  for (const ruleKey of Object.keys(rules)) {
    const rule = rules[ruleKey];
    if (!isObject$1(rule)) {
      set(willReturn, `${path}${ruleKey}`, rule);
      continue;
    }
    Object.keys(rule).filter(subruleKey => !isObject$1(rule[subruleKey])).map(subruleKey => {
      const subrule = rule[subruleKey];
      set(willReturn, `${path}${ruleKey}.${subruleKey}`, subrule);
    });
    Object.keys(rule).filter(subruleKey => isObject$1(rule[subruleKey])).map(subruleKey => {
      const subrule = rule[subruleKey];
      Object.keys(subrule).map(deepKey => {
        const deep = rule[subruleKey][deepKey];
        set(willReturn, `${path}${ruleKey}.${subruleKey}.${deepKey}`, deep);
      });
    });
  }

  return willReturn;
}

function equals(a, b) {
  if (arguments.length === 1) {
    return bHolder => equals(a, bHolder);
  }

  if (a === b) {
    return true;
  }

  const aType = type(a);

  if (aType !== type(b)) {
    return false;
  }

  if (aType === 'Array') {
    const aClone = Array.from(a);
    const bClone = Array.from(b);

    if (aClone.toString() !== bClone.toString()) {
      return false;
    }

    let loopArrayFlag = true;
    aClone.forEach((aCloneInstance, aCloneIndex) => {
      if (loopArrayFlag) {
        if (aCloneInstance !== bClone[aCloneIndex] && !equals(aCloneInstance, bClone[aCloneIndex])) {
          loopArrayFlag = false;
        }
      }
    });

    return loopArrayFlag;
  }

  if (aType === 'Object') {
    const aKeys = Object.keys(a);

    if (aKeys.length !== Object.keys(b).length) {
      return false;
    }

    let loopObjectFlag = true;
    aKeys.forEach(aKeyInstance => {
      if (loopObjectFlag) {
        const aValue = a[aKeyInstance];
        const bValue = b[aKeyInstance];

        if (aValue !== bValue && !equals(aValue, bValue)) {
          loopObjectFlag = false;
        }
      }
    });

    return loopObjectFlag;
  }

  return false;
}

function filterObject(fn, obj) {
  const willReturn = {};

  for (const prop in obj) {
    if (fn(obj[prop], prop)) {
      willReturn[prop] = obj[prop];
    }
  }

  return willReturn;
}

function filter(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => filter(fn, arrHolder);
  }

  if (arr === undefined) {
    return [];
  }

  if (!Array.isArray(arr)) {
    return filterObject(fn, arr);
  }

  let index = -1;
  let resIndex = 0;
  const len = arr.length;
  const willReturn = [];

  while (++index < len) {
    const value = arr[index];

    if (fn(value)) {
      willReturn[resIndex++] = value;
    }
  }

  return willReturn;
}

const types = ['Null', 'Undefined', 'RegExp'];

function compact(arr) {
  return filter(a => {
    const currentType = type(a);
    if (types.includes(currentType)) {
      return false;
    }
    if (currentType === 'Object') {
      return !equals(a, {});
    }

    return a.length !== 0;
  }, arr);
}

function composeAsync(...inputArguments) {
  return async function (startArgument) {
    let argumentsToPass = startArgument;

    while (inputArguments.length !== 0) {
      const fn = inputArguments.pop();
      const typeFn = type(fn);

      if (typeFn === 'Async' || typeFn === 'Promise') {
        argumentsToPass = await fn(argumentsToPass);
      } else {
        argumentsToPass = fn(argumentsToPass);
      }
    }

    return argumentsToPass;
  };
}

function compose(...fns) {
  return (...args) => {
    const list = fns.slice();
    if (list.length > 0) {
      const fn = list.pop();
      let result = fn(...args);
      while (list.length > 0) {
        result = list.pop()(result);
      }

      return result;
    }

    return undefined;
  };
}

function last(a) {
  if (typeof a === 'string') {
    return a[a.length - 1] || '';
  }

  return a[a.length - 1];
}

function baseSlice(array, start, end) {
  let index = -1;
  let length = array.length;

  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;

  const result = Array(length);

  while (++index < length) {
    result[index] = array[index + start];
  }

  return result;
}

function init(a) {
  if (typeof a === 'string') {
    return a.slice(0, -1);
  }

  return a.length ? baseSlice(a, 0, -1) : [];
}

// NODOCS
function composed(...inputs) {

  return compose(...init(inputs))(last(inputs));
}

function debounce(func, ms, immediate = false) {
  let timeout;

  return function (...input) {
    const later = function () {
      timeout = null;
      if (!immediate) {
        func.apply(null, input);
      }
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, ms);
    if (callNow) {
      func.apply(null, input);
    }
  };
}

function defaultWhen(fn, fallback, input) {
  if (arguments.length === 2) {
    return inputHolder => defaultWhen(fn, fallback, inputHolder);
  }

  return fn(input) ? input : fallback;
}

function delay(ms) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('RAMBDAX_DELAY');
    }, ms);
  });
}

//taken from the last comment of https://gist.github.com/mkuklis/5294248

function curry(f, a = []) {
  return (...p) => (o => o.length >= f.length ? f(...o) : curry(f, o))([...a, ...p]);
}

function evolveFn(rules, input) {
  const clone = Object.assign({}, input);
  const propRules = filter(x => clone[x] !== undefined)(Object.keys(rules));

  if (propRules.length === 0) {
    return input;
  }

  propRules.map(prop => {
    const fn = rules[prop];
    if (type(fn) === 'Function') {
      clone[prop] = fn(clone[prop]);
    } else if (type(fn) === 'Object') {
      clone[prop] = evolve(fn, clone[prop]);
    }
  });

  return clone;
}

const evolve = /*#__PURE__*/curry(evolveFn);

function findInObject(fn, obj) {
  if (arguments.length === 1) {
    return objHolder => findInObject(fn, objHolder);
  }
  let willReturn = { fallback: true };

  Object.entries(obj).map(([prop, value]) => {
    if (willReturn.fallback) {
      if (fn(value, prop)) {
        willReturn = {
          prop,
          value
        };
      }
    }
  });

  return willReturn;
}

function flatMap(fn, xs) {
  if (arguments.length === 1) {

    return xsHolder => flatMap(fn, xsHolder);
  }

  return [].concat(...xs.map(fn));
}

function pick(keys, obj) {
  if (arguments.length === 1) {
    return objHolder => pick(keys, objHolder);
  }
  if (obj === null || obj === undefined) {
    return undefined;
  }
  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;

  const willReturn = {};
  let counter = 0;

  while (counter < keysValue.length) {
    if (keysValue[counter] in obj) {
      willReturn[keysValue[counter]] = obj[keysValue[counter]];
    }
    counter++;
  }

  return willReturn;
}

function merge(obj, newProps) {
  if (arguments.length === 1) {
    return newPropsHolder => merge(obj, newPropsHolder);
  }

  return Object.assign({}, obj || {}, newProps || {});
}

let holder = {};

// NODOCS

/**
 * Pass string to get value
 * Pass array to get object of values
 * Pass undefined to get all data
 */
function getter(key) {
  const typeKey = type(key);

  if (typeKey === 'String') return holder[key];

  if (typeKey === 'Array') return pick(key, holder);

  return holder;
}

function setter(maybeKey, maybeValue) {
  const typeKey = type(maybeKey);
  const typeValue = type(maybeValue);

  if (typeKey === 'String') {
    if (typeValue === 'Function') {
      return holder[maybeKey] = maybeValue(holder[maybeKey]);
    }

    return holder[maybeKey] = maybeValue;
  }

  if (typeKey !== 'Object') return;

  holder = merge(holder, maybeKey);
}

function reset() {
  holder = {};
}

function greater(x, y) {
  if (y === undefined) {
    return yHolder => greater(x, yHolder);
  }

  return y > x;
}

function headObject(x) {
  if (type(x) !== 'Object') throw new Error('R.headObject.type');
  const [tag, no] = Object.keys(x);
  if (tag === undefined) throw new Error('R.headObject.less');
  if (no !== undefined) throw new Error('R.headObject.more');

  return {
    prop: tag,
    value: x[tag]
  };
}

function createThenable(x) {
  return async function (input) {
    return x(input);
  };
}

function ifElseAsync(condition, ifFn, elseFn) {

  return input => new Promise((resolve, reject) => {
    const conditionPromise = createThenable(condition);
    const ifFnPromise = createThenable(ifFn);
    const elseFnPromise = createThenable(elseFn);

    conditionPromise(input).then(conditionResult => {
      const promised = conditionResult === true ? ifFnPromise : elseFnPromise;

      promised(input).then(resolve).catch(reject);
    }).catch(reject);
  });
}

function replace(regex, replacer, str) {
  if (replacer === undefined) {
    return (replacerHolder, strHolder) => replace(regex, replacerHolder, strHolder);
  } else if (str === undefined) {
    return strHolder => replace(regex, replacer, strHolder);
  }

  return str.replace(regex, replacer);
}

function inject(injection, marker, content) {
  return replace(marker, `${marker}${injection}`, content);
}

function intersection(a, b) {
  if (b === undefined) {
    return bHolder => intersection(a, bHolder);
  }

  return filter(val => b.includes(val))(a);
}

function any(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => any(fn, arrHolder);
  }

  let counter = 0;
  while (counter < arr.length) {
    if (fn(arr[counter], counter)) {
      return true;
    }
    counter++;
  }

  return false;
}

function toLower(x) {
  return x.toLowerCase();
}

function contains(x, arr) {
  if (arguments.length === 1) {
    return arrHolder => contains(x, arrHolder);
  }

  let index = -1;
  let flag = false;

  while (++index < arr.length && !flag) {
    if (equals(arr[index], x)) {
      flag = true;
    }
  }

  return flag;
}

function test$1(regex, str) {
  if (arguments.length === 1) return strHolder => test$1(regex, strHolder);

  return str.search(regex) !== -1;
}

function all(condition, arr) {
  if (arguments.length === 1) {
    return arrHolder => all(condition, arrHolder);
  }

  return filter(condition, arr).length === arr.length;
}

function isValid({ input, schema }) {
  if (input === undefined || schema === undefined) return false;

  let flag = true;
  const boom = boomFlag => {
    if (!boomFlag) {
      flag = false;
    }
  };

  for (const requirementRaw in schema) {
    if (flag) {
      const isOptional = requirementRaw.endsWith('?');
      const requirement = isOptional ? init(requirementRaw) : requirementRaw;

      const rule = schema[requirementRaw];
      const ruleType = type(rule);
      const inputProp = input[requirement];
      const inputPropType = type(input[requirement]);
      const ok = isOptional && inputProp !== undefined || !isOptional;

      if (!ok || rule === 'any' && inputProp != null) continue;

      if (ruleType === 'Object') {
        /**
         * This rule is standalone schema, so we recursevly call `isValid`
         */
        const isValidResult = isValid({
          input: inputProp,
          schema: rule
        });
        boom(isValidResult);
      } else if (ruleType === 'String') {
        /**
         * rule is actual rule such as 'number', so the two types are compared
         */
        boom(toLower(inputPropType) === rule);
      } else if (typeof rule === 'function') {
        /**
         * rule is function so we pass to it the input
         */
        boom(rule(inputProp));
      } else if (ruleType === 'Array' && inputPropType === 'String') {
        /**
         * enum case | rule is like a: ['foo', 'bar']
         */
        boom(contains(inputProp, rule));
      } else if (ruleType === 'Array' && rule.length === 1 && inputPropType === 'Array') {
        /**
         * 1. array of type | rule is like a: ['number']
         * 2. rule is like a: [{from: 'string'}]
         */
        const currentRule = rule[0];
        const currentRuleType = type(rule[0]);
        //Check if rule is invalid
        boom(currentRuleType === 'String' || currentRuleType === 'Object');

        if (currentRuleType === 'String') {
          /**
           * 1. array of type
           */
          const isInvalidResult = any(inputPropInstance => type(inputPropInstance).toLowerCase() !== currentRule, inputProp);
          boom(!isInvalidResult);
        }

        if (currentRuleType === 'Object') {
          /**
           * 2. rule is like a: [{from: 'string'}]
           */
          const isValidResult = all(inputPropInstance => isValid({
            input: inputPropInstance,
            schema: currentRule
          }), inputProp);
          boom(isValidResult);
        }
      } else if (ruleType === 'RegExp' && inputPropType === 'String') {
        boom(test$1(rule, inputProp));
      } else {
        boom(false);
      }
    }
  }

  return flag;
}

function check(singleInput, schema) {
  return isValid({
    input: { singleInput },
    schema: { singleInput: schema }
  });
}

function ok(...inputs) {
  return (...schemas) => {
    if (inputs.length !== schemas.length) {
      throw new Error('inputs.length !== schemas.length');
    }

    let failedSchema;

    const pass = any((singleInput, i) => {
      const schema = schemas[i];

      const checked = check(singleInput, schema);
      if (!checked) {
        failedSchema = JSON.stringify({
          input: singleInput,
          schema
        });
      }

      return !checked;
    }, inputs) === false;

    if (!pass) throw new Error(`Failed R.ok with schema ${failedSchema}`);

    return true;
  };
}

function pass(...inputs) {
  return (...schemas) => {
    if (inputs.length !== schemas.length) return false;

    return any((x, i) => !check(x, schemas[i]), inputs) === false;
  };
}

function isAttach() {
  if (Object.prototype.is !== undefined) {
    return false;
  }

  Object.defineProperty(Object.prototype, 'is', {
    value: function (schema) {
      return isValid({
        input: { isProp: this },
        schema: { isProp: schema }
      });
    },
    writable: true,
    configurable: true
  });

  return true;
}

// NODOCS
function isFunction$1(fn) {
  return ['Async', 'Promise', 'Function'].includes(type(fn));
}

function isPromise(x) {
  return ['Async', 'Promise'].includes(type(x));
}

function isType(xType, x) {
  if (arguments.length === 1) {
    return xHolder => isType(xType, xHolder);
  }

  return type(x) === xType;
}

function less(x, y) {
  if (y === undefined) {
    return yHolder => less(x, yHolder);
  }

  return y < x;
}

async function mapAsyncFn(fn, arr) {
  try {
    if (Array.isArray(arr)) {
      const willReturn = [];
      for (const a of arr) {
        willReturn.push((await fn(a)));
      }

      return willReturn;
    }

    const willReturn = {};
    for (const prop in arr) {
      willReturn[prop] = await fn(arr[prop], prop);
    }

    return willReturn;
  } catch (err) {
    throw err;
  }
}

function mapAsync(fn, arr) {
  if (arguments.length === 1) {
    return async holder => await mapAsyncFn(fn, holder);
  }

  return new Promise((resolve, reject) => {
    mapAsyncFn(fn, arr).then(resolve).catch(reject);
  });
}

async function mapFastAsyncFn(fn, arr) {
  try {
    const promised = arr.map(a => fn(a));

    return await Promise.all(promised);
  } catch (err) {
    throw err;
  }
}

function mapFastAsync(fn, arr) {
  if (arguments.length === 1) {
    return async holder => await mapFastAsyncFn(fn, holder);
  }

  return new Promise((resolve, reject) => {
    mapFastAsyncFn(fn, arr).then(resolve).catch(reject);
  });
}

function mapObject(fn, obj) {
  const willReturn = {};

  for (const prop in obj) {
    willReturn[prop] = fn(obj[prop], prop);
  }

  return willReturn;
}

function map(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => map(fn, arrHolder);
  }

  if (arr === undefined) {
    return [];
  }
  if (!Array.isArray(arr)) {
    return mapObject(fn, arr);
  }

  let index = -1;
  const len = arr.length;
  const willReturn = Array(len);

  while (++index < len) {
    willReturn[index] = fn(arr[index]);
  }

  return willReturn;
}

function sort(fn, arr) {
  if (arguments.length === 1) return arrHolder => sort(fn, arrHolder);

  const arrClone = arr.concat();

  return arrClone.sort(fn);
}

function take(num, x) {
  if (arguments.length === 1) return xHolder => take(num, xHolder);

  if (typeof x === 'string') {
    return x.slice(0, num);
  }

  return baseSlice(x, 0, num);
}

const cache = {};

const normalizeObject = obj => {
  const sortFn = (a, b) => a > b;
  const willReturn = {};
  compose(map(prop => willReturn[prop] = obj[prop]), sort(sortFn))(Object.keys(obj));

  return willReturn;
};

const stringify = a => {
  if (type(a) === 'String') {
    return a;
  } else if (['Function', 'Async'].includes(type(a))) {
    const compacted = replace(/\s{1,}/g, ' ', a.toString());

    return replace(/\s/g, '_', take(15, compacted));
  } else if (type(a) === 'Object') {
    a = normalizeObject(a);
  }

  return JSON.stringify(a);
};

const generateProp = (fn, ...inputArguments) => {
  let propString = '';
  inputArguments.map(inputArgument => {
    propString += `${stringify(inputArgument)}_`;
  });

  return `${propString}${stringify(fn)}`;
};

function memoize$1(fn, ...inputArguments) {
  if (arguments.length === 1) {
    return (...inputArgumentsHolder) => memoize$1(fn, ...inputArgumentsHolder);
  }
  const prop = generateProp(fn, ...inputArguments);
  if (prop in cache) {
    return cache[prop];
  }
  if (type(fn) === 'Async') {
    return new Promise(resolve => {
      fn(...inputArguments).then(result => {
        cache[prop] = result;
        resolve(result);
      });
    });
  }
  const result = fn(...inputArguments);
  cache[prop] = result;

  return result;
}

function mergeAll(arr) {
  let willReturn = {};
  map(val => {
    willReturn = merge(willReturn, val);
  }, arr);

  return willReturn;
}

function mergeRight(x, y) {
  return merge(y, x);
}

function multiline(input, glue) {

  return input.split('\n').filter(x => x.trim().length > 0).map(x => x.trim()).join(glue !== undefined ? glue : ' ');
}

function omitBy(fn, obj) {
  if (arguments.length === 1) {
    return holder => omitBy(fn, holder);
  }

  const willReturn = {};
  for (const prop in obj) {
    if (!fn(prop, obj[prop])) {
      willReturn[prop] = obj[prop];
    }
  }

  return willReturn;
}

function onceFn(fn, context) {
  let result;

  return function () {
    if (fn) {
      result = fn.apply(context || this, arguments);
      fn = null;
    }

    return result;
  };
}

function once(fn, context) {
  if (arguments.length === 1) {
    const wrap = onceFn(fn, context);

    return curry(wrap);
  }

  return onceFn(fn, context);
}

function pickBy(fn, obj) {
  if (arguments.length === 1) {
    return holder => pickBy(fn, holder);
  }

  const willReturn = {};
  for (const prop in obj) {
    if (fn(prop, obj[prop])) {
      willReturn[prop] = obj[prop];
    }
  }

  return willReturn;
}

function pipe(...fns) {
  return compose(...fns.reverse());
}

// NODOCS
function piped(...inputs) {
  const [input, ...fnList] = inputs;

  return pipe(...fnList)(input);
}

function helper({ condition, inputArgument, prop }) {
  return new Promise((resolve, reject) => {
    if (!(type(condition) === 'Async')) {
      return resolve({
        type: prop,
        payload: condition(inputArgument)
      });
    }

    condition(inputArgument).then(result => {
      resolve({
        type: prop,
        payload: result
      });
    }).catch(err => reject(err));
  });
}

function produce(conditions, inputArgument) {
  if (arguments.length === 1) {
    return inputArgumentHolder => produce(conditions, inputArgumentHolder);
  }
  let asyncConditionsFlag = false;
  for (const prop in conditions) {
    if (asyncConditionsFlag === false && type(conditions[prop]) === 'Async') {
      asyncConditionsFlag = true;
    }
  }

  if (asyncConditionsFlag === false) {
    const willReturn = {};
    for (const prop in conditions) {
      willReturn[prop] = conditions[prop](inputArgument);
    }

    return willReturn;
  }
  const promised = [];
  for (const prop in conditions) {
    const condition = conditions[prop];
    promised.push(helper({
      inputArgument,
      condition,
      prop
    }));
  }

  return new Promise((resolve, reject) => {
    Promise.all(promised).then(results => {
      const willReturn = {};

      map(result => willReturn[result.type] = result.payload, results);

      resolve(willReturn);
    }).catch(err => reject(err));
  });
}

function promiseAllObject(promises) {
  return new Promise((res, rej) => {
    let counter = 0;
    const props = {};
    const promisedArr = [];

    for (const prop in promises) {
      props[counter] = prop;
      promisedArr.push(promises[prop]);
      counter++;
    }

    Promise.all(promisedArr).then(result => {
      const willReturn = {};
      result.map((val, key) => {
        const prop = props[key];
        willReturn[prop] = val;
      });

      res(willReturn);
    }).catch(rej);
  });
}

const promiseAllSecureWrapper = promise => new Promise(res => {
  promise.then(result => {
    res({
      payload: result,
      type: 'RESULT'
    });
  }).catch(err => {
    res({
      payload: err,
      type: 'ERROR'
    });
  });
});

async function promiseAllSecure(input) {
  try {
    const promised = map(a => promiseAllSecureWrapper(a), input);

    return await Promise.all(promised);
  } catch (err) {
    console.log(err);
  }
}

function random(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function range(start, end) {
  if (arguments.length === 1) return endHolder => range(start, endHolder);

  const willReturn = [];

  for (let i = start; i < end; i++) {
    willReturn.push(i);
  }

  return willReturn;
}

function length(x) {
  return x.length;
}

function split(glue, str) {
  if (arguments.length === 1) return strHolder => split(glue, strHolder);

  return str.split(glue);
}

function rangeBy(startNum, endNum, distance) {
  const isInteger = !distance.toString().includes('.');
  if (startNum > endNum) {
    const startNumHolder = startNum;
    startNum = endNum;
    endNum = startNumHolder;
  }
  const willReturn = [startNum];
  let valueToPush = startNum;

  if (isInteger) {
    const loopIndexes = range(0, Math.floor((endNum - startNum) / distance));
    for (const i of loopIndexes) {
      valueToPush += distance;
      willReturn.push(valueToPush);
    }
  } else {
    const decimalLength = compose(length, last, split('.'))(distance.toString());
    const loopIndexes = range(0, Math.floor((endNum - startNum) / distance));
    for (const i of loopIndexes) {
      valueToPush += distance;
      willReturn.push(Number(valueToPush.toFixed(decimalLength)));
    }
  }

  return willReturn;
}

function remove(inputs, text) {
  if (arguments.length === 1) {
    return textHolder => remove(inputs, textHolder);
  }

  if (type(inputs) !== 'Array') {
    return replace(inputs, '', text).trim();
  }

  let textCopy = text;

  inputs.forEach(singleInput => {
    textCopy = replace(singleInput, '', textCopy).trim();
  });

  return textCopy;
}

function omit(keys, obj) {
  if (arguments.length === 1) {
    return objHolder => omit(keys, objHolder);
  }
  if (obj === null || obj === undefined) {
    return undefined;
  }

  const keysValue = typeof keys === 'string' ? keys = keys.split(',') : keys;

  const willReturn = {};

  for (const key in obj) {
    if (!keysValue.includes(key)) {
      willReturn[key] = obj[key];
    }
  }

  return willReturn;
}

function renameProps(conditions, inputObject) {
  if (inputObject === undefined) {
    return inputObjectHolder => renameProps(conditions, inputObjectHolder);
  }
  const renamed = {};
  Object.keys(conditions).map(renameConditionProp => {
    if (Object.keys(inputObject).includes(renameConditionProp)) {
      renamed[conditions[renameConditionProp]] = inputObject[renameConditionProp];
    }
  });

  return merge(renamed, omit(Object.keys(conditions), inputObject));
}

const getOccurances = input => input.match(/{{[_a-zA-Z0-9]+}}/g);

const getOccuranceProp = occurance => occurance.replace(/{{|}}/g, '');

const replace$1 = ({
  inputHolder,
  prop,
  replacer
}) => inputHolder.replace(`{{${prop}}}`, replacer);

function template(input, templateInput) {
  const occurances = getOccurances(input);
  if (occurances === null) return input;

  let inputHolder = input;
  for (const occurance of occurances) {
    const prop = getOccuranceProp(occurance);
    const replacer = templateInput[prop];

    if (replacer === undefined) continue;
    inputHolder = replace$1({
      inputHolder,
      prop,
      replacer
    });
  }

  return inputHolder;
}

const evaluationsSchema = { label: 'string' };

function runTests(input) {
  const pass = ok(input)({
    testSuite: 'string',
    evaluations: [evaluationsSchema]
  });

  if (describe === undefined || !pass) {
    throw new Error('R.runTests.init');
  }
  try {
    const {
      testSuite,
      evaluations,
      data
    } = input;

    describe(testSuite, () => {
      evaluations.forEach(singleEvaluation => {
        data.forEach(dataInstance => {
          const {
            prop: tag,
            value: x
          } = headObject(dataInstance);
          const { value: evaluationFunction } = headObject(omit('label', singleEvaluation));

          const label = template(singleEvaluation.label, { tag });

          test(label, () => {
            evaluationFunction(x);
          });
        });
      });
    });
  } catch (err) {
    console.log(err);
    throw new Error('R.runTestsCatch');
  }
}

//https://github.com/staltz/zii

function s() {
  if (Object.prototype.s === undefined) {
    Object.defineProperty(Object.prototype, 's', {
      value: function (f) {
        return f(this.valueOf());
      },
      writable: true,
      configurable: true
    });

    return true;
  }

  return false;
}

function shuffle(arrayRaw) {
  const array = arrayRaw.concat();
  let counter = array.length;
  while (counter > 0) {
    const index = Math.floor(Math.random() * counter);
    counter--;
    const temp = array[counter];
    array[counter] = array[index];
    array[index] = temp;
  }

  return array;
}

const NO_MATCH_FOUND = Symbol ? /*#__PURE__*/Symbol('NO_MATCH_FOUND') : undefined;

const getMatchingKeyValuePair = (cases, testValue, defaultValue) => {
  let iterationValue;

  for (let index = 0; index < cases.length; index++) {
    iterationValue = cases[index].test(testValue);

    if (iterationValue !== NO_MATCH_FOUND) {
      return iterationValue;
    }
  }

  return defaultValue;
};

const isEqual = (testValue, matchValue) => {
  const willReturn = typeof testValue === 'function' ? testValue(matchValue) : equals(testValue, matchValue);

  return willReturn;
};

const is = (testValue, matchResult = true) => ({
  key: testValue,
  test: matchValue => isEqual(testValue, matchValue) ? matchResult : NO_MATCH_FOUND
});

class Switchem {

  constructor(defaultValue, cases, willMatch) {
    if (defaultValue !== undefined && cases === undefined && willMatch === undefined) {
      this.cases = [];
      this.defaultValue = undefined;
      this.willMatch = defaultValue;
    } else {
      this.cases = cases;
      this.defaultValue = defaultValue;
      this.willMatch = willMatch;
    }

    return this;
  }

  default(defaultValue) {
    const holder = new Switchem(defaultValue, this.cases, this.willMatch);

    return holder.match(this.willMatch);
  }

  is(testValue, matchResult) {
    return new Switchem(this.defaultValue, [...this.cases, is(testValue, matchResult)], this.willMatch);
  }

  match(matchValue) {
    return getMatchingKeyValuePair(this.cases, matchValue, this.defaultValue);
  }

}

function switcher(input) {
  return new Switchem(input);
}

function tapAsync(fn, input) {
  if (arguments.length === 1) {
    return inputHolder => tapAsync(fn, inputHolder);
  }
  if (isPromise(fn) === true) {
    return new Promise((resolve, reject) => {
      fn(input).then(() => {
        resolve(input);
      }).catch(reject);
    });
  }
  fn(input);

  return input;
}

function throttle(fn, ms) {
  let wait = false;

  return function (...input) {
    if (!wait) {
      fn.apply(null, input);
      wait = true;
      setTimeout(() => {
        wait = false;
      }, ms);
    }
  };
}

// NODOCS
function tryCatch(fn, fallback) {
  if (!isFunction$1(fn)) {
    throw new Error(`R.tryCatch | fn '${fn}'`);
  }
  const passFallback = isFunction$1(fallback);

  if (!isPromise(fn)) {
    return (...inputs) => {
      try {
        return fn(...inputs);
      } catch (e) {
        return passFallback ? fallback(...inputs) : fallback;
      }
    };
  }
  return (...inputs) => new Promise(resolve => {
    fn(...inputs).then(resolve).catch(() => {
      if (!passFallback) {
        return resolve(fallback);
      }

      if (!isPromise(fallback)) {
        return resolve(fallback(...inputs));
      }

      fallback(...inputs).then(resolve);
    });
  });
}

function validate(input, schema) {
  if (arguments.length === 2) {
    return isValid({
      input,
      schema
    });
  }

  return schemaHolder => isValid({
    input,
    schema: schemaHolder
  });
}

function when(condition, whenTrueFn) {
  if (whenTrueFn === undefined) {
    return whenTrueFnHolder => when(condition, whenTrueFnHolder);
  }

  return input => {
    const flag = typeof condition === 'boolean' ? condition : condition(input);

    if (flag) {
      return whenTrueFn(input);
    }

    return input;
  };
}

function createThenable$1(x) {
  return async function (input) {
    return x(input);
  };
}

function whenAsync(condition, whenTrueFn) {
  if (whenTrueFn === undefined) {
    return (condition, whenTrueFnHolder) => whenAsync(condition, whenTrueFnHolder);
  }

  return input => new Promise((resolve, reject) => {

    if (typeof condition === 'boolean') {
      if (condition === false) {
        return resolve(input);
      }

      whenTrueFn(input).then(resolve).catch(reject);
    } else {
      const conditionPromise = createThenable$1(condition);

      conditionPromise(input).then(conditionResult => {
        if (conditionResult === false) {
          return resolve(input);
        }

        whenTrueFn(input).then(resolve).catch(reject);
      }).catch(reject);
    }
  });
}

function where(conditions, obj) {
  if (obj === undefined) {
    return objHolder => where(conditions, objHolder);
  }
  let flag = true;
  for (const prop in conditions) {
    const result = conditions[prop](obj[prop]);
    if (flag && result === false) {
      flag = false;
    }
  }

  return flag;
}

function add(x, y) {
  if (y === undefined) {
    return yHolder => add(x, yHolder);
  }

  return x + y;
}

function addIndex(functor) {
  return function (fn, ...rest) {
    let cnt = 0;
    const newFn = (...args) => fn.apply(null, [...args, cnt++]);

    return functor.apply(null, [newFn, ...rest]);
  };
}

function adjust(fn, index, arr) {
  if (index === undefined) {
    return (indexHolder, arrHolder) => adjust(fn, indexHolder, arrHolder);
  } else if (arr === undefined) {
    return arrHolder => adjust(fn, index, arrHolder);
  }
  const clone = arr.concat();

  return clone.map((val, key) => {
    if (key === index) {
      return fn(arr[index]);
    }

    return val;
  });
}

function allPass(conditions, x) {
  if (arguments.length === 1) {
    return xHolder => allPass(conditions, xHolder);
  }

  return !any(condition => !condition(x), conditions);
}

function always(x) {
  return () => x;
}

function anyPass(conditions, x) {
  if (arguments.length === 1) {
    return xHolder => anyPass(conditions, xHolder);
  }

  return any(condition => condition(x))(conditions);
}

function append(x, arr) {
  if (arguments.length === 1) {
    return arrHolder => append(x, arrHolder);
  }

  if (typeof arr === 'string') return `${arr}${x}`;

  const clone = arr.concat();
  clone.push(x);

  return clone;
}

function assocRaw(prop, value, obj) {
  return Object.assign({}, obj, { [prop]: value });
}

const assoc = /*#__PURE__*/curry(assocRaw);

function both(x, y) {
  if (arguments.length === 1) {
    return yHolder => both(x, yHolder);
  }

  return input => x(input) && y(input);
}

function complement(fn) {
  return input => !fn(input);
}

function concat(x, y) {
  if (arguments.length === 1) {
    return yHolder => concat(x, yHolder);
  }

  return typeof x === 'string' ? `${x}${y}` : [...x, ...y];
}

const dec = x => x - 1;

function defaultTo(defaultArgument, inputArgument) {
  if (arguments.length === 1) {
    return inputArgumentHolder => defaultTo(defaultArgument, inputArgumentHolder);
  }

  return inputArgument === undefined || inputArgument === null || Number.isNaN(inputArgument) === true ? defaultArgument : inputArgument;
}

function dissoc(prop, obj) {
  if (arguments.length === 1) {
    return objHolder => dissoc(prop, objHolder);
  }

  if (obj === null || obj === undefined) {
    return {};
  }

  const willReturn = {};
  for (const p in obj) {
    willReturn[p] = obj[p];
  }
  delete willReturn[prop];

  return willReturn;
}

function divide(x, y) {
  if (arguments.length === 1) {
    return yHolder => divide(x, yHolder);
  }

  return x / y;
}

function drop(dropNumber, x) {
  if (arguments.length === 1) {
    return xHolder => drop(dropNumber, xHolder);
  }

  return x.slice(dropNumber);
}

function dropLast(dropNumber, x) {
  if (arguments.length === 1) {
    return xHolder => dropLast(dropNumber, xHolder);
  }

  return x.slice(0, -dropNumber);
}

function either(x, y) {
  if (arguments.length === 1) {
    return yHolder => either(x, yHolder);
  }

  return input => x(input) || y(input);
}

function endsWith(substr, str) {
  if (arguments.length === 1) {
    return strHolder => endsWith(substr, strHolder);
  }

  return str.endsWith(substr);
}

function F() {
  return false;
}

function find(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => find(fn, arrHolder);
  }

  return arr.find(fn);
}

function findIndex(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => findIndex(fn, arrHolder);
  }

  const len = arr.length;
  let index = -1;

  while (++index < len) {
    if (fn(arr[index])) {
      return index;
    }
  }

  return -1;
}

function flatten(arr, willReturn) {
  willReturn = willReturn === undefined ? [] : willReturn;

  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      flatten(arr[i], willReturn);
    } else {
      willReturn.push(arr[i]);
    }
  }

  return willReturn;
}

function flipExport(fn) {
  return (...input) => {
    if (input.length === 1) {
      return holder => fn(holder, input[0]);
    } else if (input.length === 2) {
      return fn(input[1], input[0]);
    }

    return undefined;
  };
}

function flip(fn, ...input) {
  return flipExport(fn);
}

function forEach(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => forEach(fn, arrHolder);
  }

  map(fn, arr);

  return arr;
}

function groupBy(fn, list) {
  if (arguments.length === 1) {
    return list => groupBy(fn, list);
  }

  const result = {};
  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    const key = fn(item);

    if (!result[key]) {
      result[key] = [];
    }

    result[key].push(item);
  }

  return result;
}

function has(prop, obj) {
  if (arguments.length === 1) {
    return objHolder => has(prop, objHolder);
  }

  return obj[prop] !== undefined;
}

function head(a) {
  if (typeof a === 'string') {
    return a[0] || '';
  }

  return a[0];
}

function identity(x) {
  return x;
}

function ifElse(condition, ifFn, elseFn) {
  if (ifFn === undefined) {
    return (ifFnHolder, elseFnHolder) => ifElse(condition, ifFnHolder, elseFnHolder);
  } else if (elseFn === undefined) {
    return elseFnHolder => ifElse(condition, ifFn, elseFnHolder);
  }

  return input => {
    const conditionResult = typeof condition === 'boolean' ? condition : condition(input);

    if (conditionResult === true) {
      return ifFn(input);
    }

    return elseFn(input);
  };
}

const inc = x => x + 1;

function includes(x, y) {
  if (arguments.length === 1) {
    return yHolder => includes(x, yHolder);
  }

  return y.includes(x);
}

function indexBy(fn, list) {
  if (arguments.length === 1) {
    return listHolder => indexBy(fn, listHolder);
  }

  const result = {};
  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    result[fn(item)] = item;
  }

  return result;
}

function indexOf(x, arr) {
  if (arguments.length === 1) {
    return arrHolder => indexOf(x, arrHolder);
  }

  let index = -1;
  const length = arr.length;

  while (++index < length) {
    if (arr[index] === x) {
      return index;
    }
  }

  return -1;
}

function is$1(xPrototype, x) {
  if (arguments.length === 1) {
    return xHolder => is$1(xPrototype, xHolder);
  }

  return x != null && x.constructor === xPrototype || x instanceof xPrototype;
}

function isNil(x) {
  return x === undefined || x === null;
}

function join(glue, arr) {
  if (arguments.length === 1) {
    return arrHolder => join(glue, arrHolder);
  }

  return arr.join(glue);
}

function keys(x) {
  return Object.keys(x);
}

function lastIndexOf(x, arr) {
  if (arguments.length === 1) {
    return arrHolder => lastIndexOf(x, arrHolder);
  }

  let willReturn = -1;

  arr.map((value, key) => {
    if (equals(value, x)) {
      willReturn = key;
    }
  });

  return willReturn;
}

function match(regex, x) {
  if (arguments.length === 1) {
    return xHolder => match(regex, xHolder);
  }

  const willReturn = x.match(regex);

  return willReturn === null ? [] : willReturn;
}

function max(x, y) {
  if (arguments.length === 1) {
    return yHolder => max(x, yHolder);
  }

  return y > x ? y : x;
}

function maxBy(fn, x, y) {
  if (arguments.length === 2) {
    return yHolder => maxBy(fn, x, yHolder);
  } else if (arguments.length === 1) {
    return (xHolder, yHolder) => maxBy(fn, xHolder, yHolder);
  }

  return fn(y) > fn(x) ? y : x;
}

function min(x, y) {
  if (arguments.length === 1) {
    return yHolder => min(x, yHolder);
  }

  return y < x ? y : x;
}

function minBy(fn, x, y) {
  if (arguments.length === 2) {
    return yHolder => minBy(fn, x, yHolder);
  } else if (arguments.length === 1) {
    return (xHolder, yHolder) => minBy(fn, xHolder, yHolder);
  }

  return fn(y) < fn(x) ? y : x;
}

function modulo(x, y) {
  if (arguments.length === 1) return yHolder => modulo(x, yHolder);

  return x % y;
}

function multiply(x, y) {
  if (arguments.length === 1) return yHolder => multiply(x, yHolder);

  return x * y;
}

function none(fn, arr) {
  if (arguments.length === 1) return arrHolder => none(fn, arrHolder);

  return arr.filter(fn).length === 0;
}

function not(x) {
  return !x;
}

function nth(index, list) {
  if (arguments.length === 1) return listHolder => nth(index, listHolder);

  const idx = index < 0 ? list.length + index : index;

  return Object.prototype.toString.call(list) === '[object String]' ? list.charAt(idx) : list[idx];
}

function partialCurry(fn, inputArguments = {}) {
  return inputArgumentsHolder => {
    if (type(fn) === 'Async' || type(fn) === 'Promise') {
      return new Promise((resolve, reject) => {
        fn(merge(inputArgumentsHolder, inputArguments)).then(resolve).catch(reject);
      });
    }

    return fn(merge(inputArgumentsHolder, inputArguments));
  };
}

function path(pathArr, obj) {
  if (arguments.length === 1) {
    return objHolder => path(pathArr, objHolder);
  }
  if (obj === null || obj === undefined) {
    return undefined;
  }
  let willReturn = obj;
  let counter = 0;

  const pathArrValue = typeof pathArr === 'string' ? pathArr.split('.') : pathArr;

  while (counter < pathArrValue.length) {
    if (willReturn === null || willReturn === undefined) {
      return undefined;
    }
    willReturn = willReturn[pathArrValue[counter]];
    counter++;
  }

  return willReturn;
}

function pathOrRaw(defaultValue, inputPath, inputObject) {
  return defaultTo(defaultValue, path(inputPath, inputObject));
}

const pathOr = /*#__PURE__*/curry(pathOrRaw);

function pickAll(keys, obj) {
  if (arguments.length === 1) {
    return objHolder => pickAll(keys, objHolder);
  }
  if (obj === null || obj === undefined) {
    return undefined;
  }
  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;

  const willReturn = {};
  let counter = 0;

  while (counter < keysValue.length) {
    if (keysValue[counter] in obj) {
      willReturn[keysValue[counter]] = obj[keysValue[counter]];
    } else {
      willReturn[keysValue[counter]] = undefined;
    }
    counter++;
  }

  return willReturn;
}

function pluck(keyToPluck, arr) {
  if (arguments.length === 1) return arrHolder => pluck(keyToPluck, arrHolder);

  const willReturn = [];

  map(val => {
    if (!(val[keyToPluck] === undefined)) {
      willReturn.push(val[keyToPluck]);
    }
  }, arr);

  return willReturn;
}

function prepend(x, arr) {
  if (arguments.length === 1) return arrHolder => prepend(x, arrHolder);

  if (typeof arr === 'string') {

    return `${x}${arr}`;
  }
  const clone = arr.concat();
  clone.unshift(x);

  return clone;
}

function prop(key, obj) {
  if (arguments.length === 1) return objHolder => prop(key, objHolder);

  return obj[key];
}

function propEq(key, x, obj) {
  if (x === undefined) {
    return (xHolder, objHolder) => propEq(key, xHolder, objHolder);
  } else if (obj === undefined) {
    return objHolder => propEq(key, x, objHolder);
  }

  return obj[key] === x;
}

function reduce(fn, initialValue, arr) {
  if (initialValue === undefined) {
    return (initialValueHolder, arrHolder) => reduce(fn, initialValueHolder, arrHolder);
  } else if (arr === undefined) {
    return arrHolder => reduce(fn, initialValue, arrHolder);
  }

  return arr.reduce(fn, initialValue);
}

function reject(fn, arr) {
  if (arguments.length === 1) return arrHolder => reject(fn, arrHolder);

  return filter(x => !fn(x), arr);
}

function repeat(x, num) {
  if (arguments.length === 1) {
    return numHolder => repeat(x, numHolder);
  }
  const willReturn = Array(num);

  return willReturn.fill(x);
}

function reverse(arr) {
  const clone = arr.concat();

  return clone.reverse();
}

function sortBy(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => sortBy(fn, arrHolder);
  }
  const arrClone = arr.concat();

  return arrClone.sort((a, b) => {
    const fnA = fn(a);
    const fnB = fn(b);

    return fnA < fnB ? -1 : fnA > fnB ? 1 : 0;
  });
}

function splitEvery(num, x) {
  if (arguments.length === 1) return xHolder => splitEvery(num, xHolder);

  const numValue = num > 1 ? num : 1;

  const willReturn = [];
  let counter = 0;

  while (counter < x.length) {
    willReturn.push(x.slice(counter, counter += numValue));
  }

  return willReturn;
}

function startsWith(x, y) {
  if (arguments.length === 1) return yHolder => startsWith(x, yHolder);

  return y.startsWith(x);
}

function subtract(x, y) {
  if (arguments.length === 1) return yHolder => subtract(x, yHolder);

  return x - y;
}

function T() {
  return true;
}

function tail(arr) {
  return drop(1, arr);
}

function takeLast(num, x) {
  if (arguments.length === 1) return xHolder => takeLast(num, xHolder);

  const len = x.length;

  let numValue = num > len ? len : num;

  if (typeof x === 'string') {

    return x.slice(len - numValue);
  }
  numValue = len - numValue;

  return baseSlice(x, numValue, len);
}

function tap(fn, x) {
  if (arguments.length === 1) return xHolder => tap(fn, xHolder);

  fn(x);

  return x;
}

function times(fn, num) {
  if (arguments.length === 1) return numHolder => times(fn, numHolder);

  return map(fn, range(0, num));
}

function toString$1(x) {
  return x.toString();
}

function toUpper(x) {
  return x.toUpperCase();
}

function trim(str) {
  return str.trim();
}

function uniq(arr) {
  let index = -1;
  const willReturn = [];

  while (++index < arr.length) {
    const value = arr[index];

    if (!contains(value, willReturn)) {
      willReturn.push(value);
    }
  }

  return willReturn;
}

function uniqWith(fn, arr) {
  if (arguments.length === 1) return arrHolder => uniqWith(fn, arrHolder);

  let index = -1;
  const len = arr.length;
  const willReturn = [];

  while (++index < arr.length) {
    const value = arr[index];
    const flag = any(willReturnInstance => fn(value, willReturnInstance), willReturn);

    if (!flag) {
      willReturn.push(value);
    }
  }

  return willReturn;
}

function update(index, newValue, arr) {
  if (newValue === undefined) {
    return (newValueHolder, arrHolder) => update(index, newValueHolder, arrHolder);
  } else if (arr === undefined) {
    return arrHolder => update(index, newValue, arrHolder);
  }
  const arrClone = arr.concat();

  return arrClone.fill(newValue, index, index + 1);
}

function values(obj) {
  const willReturn = [];

  for (const key in obj) {
    willReturn.push(obj[key]);
  }

  return willReturn;
}

function without(itemsToOmit, collection) {
  return reduce((accum, item) => !contains(item, itemsToOmit) ? accum.concat(item) : accum, [], collection);
}

function zip(x, y) {
  if (arguments.length === 1) return yHolder => zip(x, yHolder);

  return addIndex(reduce)((accum, value, index) => y[index] ? accum.concat([[value, y[index]]]) : accum, [], x);
}

function zipObj(x, y) {
  if (arguments.length === 1) return yHolder => zipObj(x, yHolder);

  return x.reduce((prev, xInstance, i) => {
    prev[xInstance] = y[i];

    return prev;
  }, {});
}

const DELAY = 'RAMBDAX_DELAY';

exports.DELAY = DELAY;
exports.ok = ok;
exports.allFalse = allFalse;
exports.allTrue = allTrue;
exports.anyFalse = anyFalse;
exports.anyTrue = anyTrue;
exports.change = change;
exports.compact = compact;
exports.composeAsync = composeAsync;
exports.composed = composed;
exports.debounce = debounce;
exports.defaultWhen = defaultWhen;
exports.delay = delay;
exports.evolve = evolve;
exports.findInObject = findInObject;
exports.flatMap = flatMap;
exports.getter = getter;
exports.setter = setter;
exports.reset = reset;
exports.greater = greater;
exports.headObject = headObject;
exports.ifElseAsync = ifElseAsync;
exports.inject = inject;
exports.intersection = intersection;
exports.pass = pass;
exports.isAttach = isAttach;
exports.isFunction = isFunction$1;
exports.isPromise = isPromise;
exports.isType = isType;
exports.isValid = isValid;
exports.less = less;
exports.mapAsync = mapAsync;
exports.mapFastAsync = mapFastAsync;
exports.memoize = memoize$1;
exports.mergeAll = mergeAll;
exports.mergeRight = mergeRight;
exports.multiline = multiline;
exports.omitBy = omitBy;
exports.once = once;
exports.pickBy = pickBy;
exports.piped = piped;
exports.produce = produce;
exports.promiseAllObject = promiseAllObject;
exports.promiseAllSecure = promiseAllSecure;
exports.random = random;
exports.rangeBy = rangeBy;
exports.remove = remove;
exports.renameProps = renameProps;
exports.runTests = runTests;
exports.s = s;
exports.shuffle = shuffle;
exports.switcher = switcher;
exports.tapAsync = tapAsync;
exports.template = template;
exports.throttle = throttle;
exports.tryCatch = tryCatch;
exports.validate = validate;
exports.when = when;
exports.whenAsync = whenAsync;
exports.where = where;
exports.add = add;
exports.addIndex = addIndex;
exports.adjust = adjust;
exports.all = all;
exports.allPass = allPass;
exports.always = always;
exports.any = any;
exports.anyPass = anyPass;
exports.append = append;
exports.assoc = assoc;
exports.both = both;
exports.complement = complement;
exports.compose = compose;
exports.concat = concat;
exports.contains = contains;
exports.curry = curry;
exports.dec = dec;
exports.defaultTo = defaultTo;
exports.dissoc = dissoc;
exports.divide = divide;
exports.drop = drop;
exports.dropLast = dropLast;
exports.either = either;
exports.endsWith = endsWith;
exports.equals = equals;
exports.F = F;
exports.filter = filter;
exports.find = find;
exports.findIndex = findIndex;
exports.flatten = flatten;
exports.flip = flip;
exports.forEach = forEach;
exports.groupBy = groupBy;
exports.has = has;
exports.head = head;
exports.identity = identity;
exports.ifElse = ifElse;
exports.inc = inc;
exports.includes = includes;
exports.indexBy = indexBy;
exports.indexOf = indexOf;
exports.init = init;
exports.is = is$1;
exports.isNil = isNil;
exports.join = join;
exports.keys = keys;
exports.last = last;
exports.lastIndexOf = lastIndexOf;
exports.length = length;
exports.map = map;
exports.match = match;
exports.merge = merge;
exports.max = max;
exports.maxBy = maxBy;
exports.min = min;
exports.minBy = minBy;
exports.modulo = modulo;
exports.multiply = multiply;
exports.none = none;
exports.not = not;
exports.nth = nth;
exports.omit = omit;
exports.partialCurry = partialCurry;
exports.path = path;
exports.pathOr = pathOr;
exports.pick = pick;
exports.pickAll = pickAll;
exports.pipe = pipe;
exports.pluck = pluck;
exports.prepend = prepend;
exports.prop = prop;
exports.propEq = propEq;
exports.range = range;
exports.reduce = reduce;
exports.reject = reject;
exports.repeat = repeat;
exports.replace = replace;
exports.reverse = reverse;
exports.sort = sort;
exports.sortBy = sortBy;
exports.split = split;
exports.splitEvery = splitEvery;
exports.startsWith = startsWith;
exports.subtract = subtract;
exports.T = T;
exports.tail = tail;
exports.take = take;
exports.takeLast = takeLast;
exports.tap = tap;
exports.test = test$1;
exports.times = times;
exports.toLower = toLower;
exports.toString = toString$1;
exports.toUpper = toUpper;
exports.trim = trim;
exports.type = type;
exports.uniq = uniq;
exports.uniqWith = uniqWith;
exports.update = update;
exports.values = values;
exports.without = without;
exports.zip = zip;
exports.zipObj = zipObj;
//# sourceMappingURL=rambdax.js.map
